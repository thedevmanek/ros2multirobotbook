<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cpp Tutorial - Programming Multiple Robots with ROS 2</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="open-in.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item "><a href="demos.html"><strong aria-hidden="true">1.2.</strong> Demos</a></li></ol></li><li class="chapter-item "><a href="ros2.html"><strong aria-hidden="true">2.</strong> ROS 2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ros2_tools_resources.html"><strong aria-hidden="true">2.1.</strong> ROS Resources</a></li><li class="chapter-item "><a href="ros2_design_patterns.html"><strong aria-hidden="true">2.2.</strong> ROS Concepts and Design Patterns</a></li><li class="chapter-item "><a href="ros2_cli.html"><strong aria-hidden="true">2.3.</strong> The ROS Command Line Interface</a></li><li class="chapter-item "><a href="ros2_api.html"><strong aria-hidden="true">2.4.</strong> The ROS API</a></li></ol></li><li class="chapter-item "><a href="traffic-editor.html"><strong aria-hidden="true">3.</strong> Traffic Editor</a></li><li class="chapter-item "><a href="simulation.html"><strong aria-hidden="true">4.</strong> Simulation</a></li><li class="chapter-item "><a href="rmf-core.html"><strong aria-hidden="true">5.</strong> RMF Core Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rmf-core_faq.html"><strong aria-hidden="true">5.1.</strong> Frequently Asked Questions</a></li></ol></li><li class="chapter-item "><a href="task.html"><strong aria-hidden="true">6.</strong> Tasks in RMF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="task_planner.html"><strong aria-hidden="true">6.1.</strong> RMF Task Allocation Planner</a></li><li class="chapter-item "><a href="task_types.html"><strong aria-hidden="true">6.2.</strong> Currently supported Tasks</a></li><li class="chapter-item "><a href="task_userdefined.html"><strong aria-hidden="true">6.3.</strong> User-defined Tasks</a></li><li class="chapter-item "><a href="task_new.html"><strong aria-hidden="true">6.4.</strong> Supporting a new Task</a></li></ol></li><li class="chapter-item "><a href="soss.html"><strong aria-hidden="true">7.</strong> SOSS</a></li><li class="chapter-item expanded "><a href="integration.html"><strong aria-hidden="true">8.</strong> Integration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="integration_nav-maps.html"><strong aria-hidden="true">8.1.</strong> Navigation Maps</a></li><li class="chapter-item expanded "><a href="integration_fleets.html"><strong aria-hidden="true">8.2.</strong> Mobile Robot Fleets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integration_fleets_tutorial.html"><strong aria-hidden="true">8.2.1.</strong> Tutorials</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="integration_fleets_tutorial_python.html"><strong aria-hidden="true">8.2.1.1.</strong> Python Tutorial</a></li><li class="chapter-item expanded "><a href="integration_fleets_tutorial_cpp.html" class="active"><strong aria-hidden="true">8.2.1.2.</strong> Cpp Tutorial</a></li></ol></li></ol></li><li class="chapter-item "><a href="integration_free-fleet.html"><strong aria-hidden="true">8.3.</strong> Free Fleet</a></li><li class="chapter-item "><a href="integration_read-only.html"><strong aria-hidden="true">8.4.</strong> Read-Only Fleets</a></li><li class="chapter-item "><a href="integration_doors.html"><strong aria-hidden="true">8.5.</strong> Doors</a></li><li class="chapter-item "><a href="integration_lifts.html"><strong aria-hidden="true">8.6.</strong> Lifts (Elevators)</a></li><li class="chapter-item "><a href="integration_workcells.html"><strong aria-hidden="true">8.7.</strong> Workcells</a></li></ol></li><li class="chapter-item "><a href="rmf-web.html"><strong aria-hidden="true">9.</strong> RMF Web</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ui.html"><strong aria-hidden="true">9.1.</strong> User Interfaces</a></li></ol></li><li class="chapter-item "><a href="security.html"><strong aria-hidden="true">10.</strong> Security</a></li><li class="chapter-item "><a href="roadmap.html"><strong aria-hidden="true">11.</strong> Roadmap</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/osrf/ros2multirobotbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fleet-adapter-c-tutorial"><a class="header" href="#fleet-adapter-c-tutorial">Fleet Adapter C++ Tutorial</a></h1>
<blockquote>
<p>The files mentioned in this tutorial can be found <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv">here</a></p>
</blockquote>
<h2 id="adapterhpp"><a class="header" href="#adapterhpp"><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/Adapter.hpp">Adapter.hpp</a></a></h2>
<pre><code class="language-cpp">#ifndef RMF_FLEET_ADAPTER__AGV__ADAPTER_HPP
#define RMF_FLEET_ADAPTER__AGV__ADAPTER_HPP

#include &lt;rmf_fleet_adapter/agv/FleetUpdateHandle.hpp&gt;
#include &lt;rmf_fleet_adapter/agv/EasyTrafficLight.hpp&gt;

#include &lt;rmf_traffic/agv/VehicleTraits.hpp&gt;
#include &lt;rmf_traffic/agv/Graph.hpp&gt;

#include &lt;rclcpp/node.hpp&gt;

namespace rmf_fleet_adapter {
namespace agv {
class Adapter : public std::enable_shared_from_this&lt;Adapter&gt;
{
public:

  static std::shared_ptr&lt;Adapter&gt; init_and_make(
    const std::string&amp; node_name,
    std::optional&lt;rmf_traffic::Duration&gt; discovery_timeout = std::nullopt);

  static std::shared_ptr&lt;Adapter&gt; make(
    const std::string&amp; node_name,
    const rclcpp::NodeOptions&amp; node_options = rclcpp::NodeOptions(),
    std::optional&lt;rmf_traffic::Duration&gt; discovery_timeout = std::nullopt);

  std::shared_ptr&lt;FleetUpdateHandle&gt; add_fleet(
    const std::string&amp; fleet_name,
    rmf_traffic::agv::VehicleTraits traits,
    rmf_traffic::agv::Graph navigation_graph,
    std::optional&lt;std::string&gt; server_uri = std::nullopt);

  using Blockers = std::vector&lt;EasyTrafficLight::Blocker&gt;;

  void add_easy_traffic_light(
    std::function&lt;void(EasyTrafficLightPtr handle)&gt; handle_callback,
    const std::string&amp; fleet_name,
    const std::string&amp; robot_name,
    rmf_traffic::agv::VehicleTraits traits,
    std::function&lt;void()&gt; pause_callback,
    std::function&lt;void()&gt; resume_callback,
    std::function&lt;void(Blockers)&gt; deadlock_callback = nullptr);


  /// Get the rclcpp::Node that this adapter will be using for communication.
  std::shared_ptr&lt;rclcpp::Node&gt; node();

  /// const-qualified node()
  std::shared_ptr&lt;const rclcpp::Node&gt; node() const;

  /// Begin running the event loop for this adapter. The event loop will operate
  /// in another thread, so this function is non-blocking.
  Adapter&amp; start();

  /// Stop the event loop if it is running.
  Adapter&amp; stop();

  /// Wait until the adapter is done spinning.
  ///
  /// \sa wait_for()
  Adapter&amp; wait();

  /// Wait until the adapter is done spinning, or until the maximum wait time
  /// duration is reached.
  ///
  /// \sa wait()
  Adapter&amp; wait_for(std::chrono::nanoseconds max_wait);

  class Implementation;
private:
  Adapter();
  rmf_utils::unique_impl_ptr&lt;Implementation&gt; _pimpl;
};

using AdapterPtr = std::shared_ptr&lt;Adapter&gt;;
using ConstAdapterPtr = std::shared_ptr&lt;const Adapter&gt;;

} // namespace agv
} // namespace rmf_fleet_adapter

#endif // RMF_FLEET_ADAPTER__AGV__ADAPTER_HPP

</code></pre>
<p><code>init_and_make</code> will initialize rclcpp context and makes an adapter instance.You can add the fleets to be adapted.
takes two arguments</p>
<ul>
<li>node_name - The name of rclcpp node that will be produced for this adapter.</li>
<li>discovery_timeout - The minimum time it will wait to discover the schedule node before giving up. If the default <code>rmf_utils:nullopt</code> is used it will use <code>discovery_timeout</code>node parameter or wait for 1 minute if<code>discovery_timeout</code> is not defined.</li>
</ul>
<p><code>make</code> instantiates an rclcpp::Node like <code>init_and_make</code> however it is more customisable.</p>
<ul>
<li>node_name - The name of rclcpp node that will be produced for this adapter.</li>
<li>node_options - It can be used to customize the node.</li>
<li>discovery_timeout - The minimum time it will wait to discover the schedule node before giving up. If the default <code>rmf_utils:nullopt</code> is used it will use <code>discovery_timeout</code> node parameter or wait for 1 minute if <code>discovery_timeout</code> is not defined.</li>
</ul>
<p><code>add_fleet</code> allows to add a fleet that needs to be adapted.</p>
<ul>
<li>fleet_name - name of the fleet</li>
<li>traits - specify approximate traits of the vehicle.</li>
<li>navigation_graph - specify navigation graph used by the vehicles in the fleet</li>
<li>server_uri - uri of the websocket server that receives updates on the tasks and states. If the default <code>rmf_utils:nullopt</code> is used it will not publish any data.</li>
</ul>
<p><code>add_easy_traffic_light</code> helps you create simple version of traffic light which allows to manage robot that can only support pause or resume commands.This API is simpler to use than the standard traffic light API but it provides less information about the exact timing needed for the starts and stops.This API must only be used if system integrators can ensure very low-latency and reliable connections to the robots to ensure that commands arrive on time.</p>
<ul>
<li>handle_callback -The callback that will be triggered when the EasyTrafficLight handle is ready to be used. This callback will only be triggered once.</li>
<li>fleet_name - The name of the fleet</li>
<li>robot_name -The name of the robot</li>
<li>traits -The traits of the robot</li>
<li>pause_callback -The callback that should be triggered by the traffic light when an immediate pause is needed.</li>
<li>resume_callback -The callback that will be triggered by the traffic light when the robot may resume moving forward.</li>
<li>deadlock_callbackThe callback that will be triggered by the traffic light if there is a permanent blocker disrupting the ability of this vehicle to proceed.Manual intervention may be required in this circumstance. A callback does not need to be provided for this. Either way, an error message will be printed to the log.</li>
</ul>
<h2 id="fleetupdatehandlehpp"><a class="header" href="#fleetupdatehandlehpp"><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp">FleetUpdateHandle.hpp</a></a></h2>
<p>The Update Handle works as handler between the fleet robots and the fleetadapter.</p>
<pre><code class="language-c++">
namespace rmf_fleet_adapter {
namespace agv {

//==============================================================================
class FleetUpdateHandle : public std::enable_shared_from_this&lt;FleetUpdateHandle&gt;
{
public:

  void add_robot(
    std::shared_ptr&lt;RobotCommandHandle&gt; command,
    const std::string&amp; name,
    const rmf_traffic::Profile&amp; profile,
    rmf_traffic::agv::Plan::StartSet start,
    std::function&lt;void(std::shared_ptr&lt;RobotUpdateHandle&gt; handle)&gt; handle_cb);

  /// Confirmation is a class used by the task acceptance callbacks to decide if
  /// a task description should be accepted.
  class Confirmation
  {
  public:

    /// Constructor
    Confirmation();

    /// Call this function to decide that you want to accept the task request.
    /// If this function is never called, it will be assumed that the task is
    /// rejected.
    Confirmation&amp; accept();

    /// Check whether
    bool is_accepted() const;

    /// Call this function to bring attention to errors related to the task
    /// request. Each call to this function will overwrite any past calls, so
    /// it is recommended to only call it once.
    Confirmation&amp; errors(std::vector&lt;std::string&gt; error_messages);

    /// Call this function to add errors instead of overwriting the ones that
    /// were already there.
    Confirmation&amp; add_errors(std::vector&lt;std::string&gt; error_messages);

    /// Check the errors that have been given to this confirmation.
    const std::vector&lt;std::string&gt;&amp; errors() const;

    class Implementation;
  private:
    rmf_utils::impl_ptr&lt;Implementation&gt; _pimpl;
  };

  using ConsiderRequest =
    std::function&lt;void(
        const nlohmann::json&amp; description,
        Confirmation&amp; confirm)
    &gt;;

  FleetUpdateHandle&amp; consider_delivery_requests(
    ConsiderRequest consider_pickup,
    ConsiderRequest consider_dropoff);


  FleetUpdateHandle&amp; consider_cleaning_requests(ConsiderRequest consider);

  FleetUpdateHandle&amp; consider_patrol_requests(ConsiderRequest consider);

  FleetUpdateHandle&amp; consider_composed_requests(ConsiderRequest consider);


  FleetUpdateHandle&amp; add_performable_action(
    const std::string&amp; category,
    ConsiderRequest consider);

  /// Specify a set of lanes that should be closed.
  void close_lanes(std::vector&lt;std::size_t&gt; lane_indices);

  /// Specify a set of lanes that should be open.
  void open_lanes(std::vector&lt;std::size_t&gt; lane_indices);


  bool set_task_planner_params(
    std::shared_ptr&lt;rmf_battery::agv::BatterySystem&gt; battery_system,
    std::shared_ptr&lt;rmf_battery::MotionPowerSink&gt; motion_sink,
    std::shared_ptr&lt;rmf_battery::DevicePowerSink&gt; ambient_sink,
    std::shared_ptr&lt;rmf_battery::DevicePowerSink&gt; tool_sink,
    double recharge_threshold,
    double recharge_soc,
    bool account_for_battery_drain,
    rmf_task::ConstRequestFactoryPtr finishing_requst = nullptr);

  using AcceptTaskRequest =
    std::function&lt;bool(const rmf_task_msgs::msg::TaskProfile&amp; profile)&gt;;

  using AcceptDeliveryRequest =
    std::function&lt;bool(const rmf_task_msgs::msg::Delivery&amp; request)&gt;;

  /// Specify the default value for how high the delay of the current itinerary
  /// can become before it gets interrupted and replanned. A nullopt value will
  /// allow for an arbitrarily long delay to build up without being interrupted.
  FleetUpdateHandle&amp; default_maximum_delay(
    std::optional&lt;rmf_traffic::Duration&gt; value);

  /// Get the default value for the maximum acceptable delay.
  std::optional&lt;rmf_traffic::Duration&gt; default_maximum_delay() const;

  /// The behavior is identical to fleet_state_topic_publish_period
  [[deprecated(&quot;Use fleet_state_topic_publish_period instead&quot;)]]
  FleetUpdateHandle&amp; fleet_state_publish_period(
    std::optional&lt;rmf_traffic::Duration&gt; value);

  /// Specify a period for how often the fleet state message is published for
  /// this fleet. Passing in std::nullopt will disable the fleet state message
  /// publishing. The default value is 1s.
  FleetUpdateHandle&amp; fleet_state_topic_publish_period(
    std::optional&lt;rmf_traffic::Duration&gt; value);

  /// Specify a period for how often the fleet state is updated in the database
  /// and to the API server. This is separate from publishing the fleet state
  /// over the ROS2 fleet state topic. Passing in std::nullopt will disable
  /// the updating, but this is not recommended unless you intend to provide the
  /// API server with the fleet states through some other means.
  ///
  /// The default value is 1s.
  FleetUpdateHandle&amp; fleet_state_update_period(
    std::optional&lt;rmf_traffic::Duration&gt; value);

  /// Set a callback for listening to update messages (e.g. fleet states and
  /// task updates). This will not receive any update messages that happened
  /// before the listener was set.
  FleetUpdateHandle&amp; set_update_listener(
    std::function&lt;void(const nlohmann::json&amp;)&gt; listener);

  // Do not allow moving
  FleetUpdateHandle(FleetUpdateHandle&amp;&amp;) = delete;
  FleetUpdateHandle&amp; operator=(FleetUpdateHandle&amp;&amp;) = delete;

  class Implementation;
private:
  FleetUpdateHandle();
  rmf_utils::unique_impl_ptr&lt;Implementation&gt; _pimpl;
};

using FleetUpdateHandlePtr = std::shared_ptr&lt;FleetUpdateHandle&gt;;
using ConstFleetUpdateHandlePtr = std::shared_ptr&lt;const FleetUpdateHandle&gt;;

} // namespace agv
} // namespace rmf_fleet_adapter

#endif // RMF_FLEET_ADAPTER__AGV__FLEETUPDATEHANDLE_HPP

</code></pre>
<p><code>add_robot</code>
This function will allow you to add a robot to the fleet.</p>
<ul>
<li><code>command</code>
A reference to a command handle for this robot.</li>
<li><code>name</code>
The name of this robot.</li>
<li><code>profile</code>
The profile of this robot. This profile should account for the largest possible payload that the robot might carry.</li>
<li><code>start</code> The initial location of the robot, expressed as <code>Plan::StartSet</code>. Multiple Start objects might be needed if the robot is not starting precisely on a waypoint.The function <code>rmf_traffic::agv::compute_plan_starts()</code> may help with this.</li>
<li><code>handle_cb</code>
This callback function will get triggered when the RobotUpdateHandle is ready to be used by the Fleet API side of the Adapter. Setting up a new robot requires communication with the Schedule Node, so there may be a delay before the robot is ready to be used.</li>
</ul>
<p><code>add_performable_action</code>
Allow this fleet adapter to execute a PerformAction activity of specified
category which may be present in sequence event.</p>
<ul>
<li><code>category</code>
A string that categorizes the action. This value should be used when
filling out the category field in event_description_PerformAction.json
schema.</li>
<li><code>consider</code>
Decide whether to accept the action based on the description field in
event_description_PerformAction.json schema.</li>
</ul>
<p><code>set_task_planner_params</code>
Set the parameters required for task planning. Without calling this
function, this fleet will not bid for and accept tasks.</p>
<ul>
<li><code>battery_system</code>
Specify the battery system used by the vehicles in this fleet.</li>
<li><code>motion_sink</code>
Specify the motion sink that describes the vehicles in this fleet.</li>
<li><code>ambient_sink</code>
Specify the device sink for ambient sensors used by the vehicles in this fleet.</li>
<li><code>tool_sink</code>
Specify the device sink for special tools used by the vehicles in this fleet.</li>
<li><code>recharge_threshold</code>
The threshold for state of charge below which robots in this fleet
will cease to operate and require recharging. A value between 0.0 and
1.0 should be specified.
When the robot is idle, a timer periodically computes the estimated battery drain if the robot were to head back to the charger now. If the battery level after the estimated drain is within a safety factor applied to the recharge_threshold, the TaskManager will automatically begin a task to take the robot back to its charging station.
The recharge_threshold is used in a similar manner during task allocation. When deciding the order of tasks performed, the TaskPlanner will estimate the battery level of the robot after performing a task A. If the estimate is below the recharge_threshold, it will then check if the robot can perform task A if it performed a recharge task before this. If this is the case then it will automatically include a recharge task before task A. If it still cannot perform task A even after recharging, it will discard the possibility of doing task A in that sequence.</li>
<li><code>recharge_soc</code>
The state of charge to which robots in this fleet should be charged up
to by automatic recharging tasks. A value between 0.0 and 1.0 should be
specified.</li>
<li><code>account_for_battery_drain</code>
Specify whether battery drain is to be considered while allocating tasks.
If false, battery drain will not be considered when planning for tasks.
As a consequence, charging tasks will not be automatically assigned to
vehicles in this fleet when battery levels fall below the
recharge_threshold.</li>
<li><code>finishing_request</code>
A factory for a request that should be performed by each robot in this
fleet at the end of its assignments.</li>
</ul>
<p><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/RobotUpdateHandle.hpp"><code>RobotUpdateHandle.hpp</code></a>
The <code>RobotUpdateHandle</code> helps in sending updates to the robot.</p>
<pre><code class="language-cpp">namespace rmf_fleet_adapter {
namespace agv {

//==============================================================================
/// You will be given an instance of this class every time you add a new robot
/// to your fleet. Use that instance to send updates to RoMi-H about your
/// robot's state.
class RobotUpdateHandle
{
public:

  [[deprecated(&quot;Use replan() instead&quot;)]]
  void interrupted();


  void replan();

  void update_position(
    std::size_t waypoint,
    double orientation);

  void update_position(
    const Eigen::Vector3d&amp; position,
    const std::vector&lt;std::size_t&gt;&amp; lanes);

  void update_position(
    const Eigen::Vector3d&amp; position,
    std::size_t target_waypoint);

  void update_position(
    const std::string&amp; map_name,
    const Eigen::Vector3d&amp; position,
    const double max_merge_waypoint_distance = 0.1,
    const double max_merge_lane_distance = 1.0,
    const double min_lane_length = 1e-8);

  void update_position(rmf_traffic::agv::Plan::StartSet position);

  RobotUpdateHandle&amp; set_charger_waypoint(const std::size_t charger_wp);

  void update_battery_soc(const double battery_soc);

  void override_status(std::optional&lt;std::string&gt; status);

  RobotUpdateHandle&amp; maximum_delay(
    rmf_utils::optional&lt;rmf_traffic::Duration&gt; value);


  rmf_utils::optional&lt;rmf_traffic::Duration&gt; maximum_delay() const;

  /// The ActionExecution class should be used to manage the execution of and
  /// provide updates on ongoing actions.
  class ActionExecution
  {
  public:
    /// Update the amount of time remaining for this action
    void update_remaining_time(rmf_traffic::Duration remaining_time_estimate);

    void underway(std::optional&lt;std::string&gt; text);

    void error(std::optional&lt;std::string&gt; text);


    void delayed(std::optional&lt;std::string&gt; text);


    void blocked(std::optional&lt;std::string&gt; text);

    void finished();

    bool okay() const;

    class Implementation;
  private:
    ActionExecution();
    rmf_utils::impl_ptr&lt;Implementation&gt; _pimpl;
  };

  using ActionExecutor = std::function&lt;void(
        const std::string&amp; category,
        const nlohmann::json&amp; description,
        ActionExecution execution)&gt;;

  /// Set the ActionExecutor for this robot
  void set_action_executor(ActionExecutor action_executor);


  void submit_direct_request(
    nlohmann::json task_request,
    std::string request_id,
    std::function&lt;void(nlohmann::json response)&gt; receive_response);

  /// An object to maintain an interruption of the current task. When this
  /// object is destroyed, the task will resume.
  class Interruption
  {
  public:
    /// Call this function to resume the task while providing labels for
    /// resuming.
    void resume(std::vector&lt;std::string&gt; labels);

    class Implementation;
  private:
    Interruption();
    rmf_utils::unique_impl_ptr&lt;Implementation&gt; _pimpl;
  };

  Interruption interrupt(
    std::vector&lt;std::string&gt; labels,
    std::function&lt;void()&gt; robot_is_interrupted);


  void cancel_task(
    std::string task_id,
    std::vector&lt;std::string&gt; labels,
    std::function&lt;void(bool task_was_found)&gt; on_cancellation);

  void kill_task(
    std::string task_id,
    std::vector&lt;std::string&gt; labels,
    std::function&lt;void(bool task_was_found)&gt; on_kill);

  enum class Tier
  {
    /// General status information, does not require special attention
    Info,

    /// Something unusual that might require attention
    Warning,

    /// A critical failure that requires immediate operator attention
    Error
  };

  /// An object to maintain an issue that is happening with the robot. When this
  /// object is destroyed without calling resolve(), the issue will be
  /// &quot;dropped&quot;, which issues a warning to the log.
  class IssueTicket
  {
  public:

    /// Indicate that the issue has been resolved. The provided message will be
    /// logged for this robot and the issue will be removed from the robot
    /// state.
    void resolve(nlohmann::json msg);

    class Implementation;
  private:
    IssueTicket();
    rmf_utils::unique_impl_ptr&lt;Implementation&gt; _pimpl;
  };


  IssueTicket create_issue(
    Tier tier, std::string category, nlohmann::json detail);

  // TODO(MXG): Should we offer a &quot;clear_all_issues&quot; function?

  /// Add a log entry with Info severity
  void log_info(std::string text);

  /// Add a log entry with Warning severity
  void log_warning(std::string text);

  /// Add a log entry with Error severity
  void log_error(std::string text);

  /// Toggle the responsive wait behavior for this robot. When responsive wait
  /// is active, the robot will remain in the traffic schedule when it is idle
  /// and will negotiate its position with other traffic participants to
  /// potentially move out of their way.
  ///
  /// Disabling this behavior may be helpful to reduce CPU load or prevent
  /// parked robots from moving or being seen as conflicts when they are not
  /// actually at risk of creating traffic conflicts.
  ///
  /// By default this behavior is enabled.
  void enable_responsive_wait(bool value);

  class Implementation;

  /// This API is experimental and will not be supported in the future. Users
  /// are to avoid relying on these feature for any integration.
  class Unstable
  {
  public:
    /// True if this robot is allowed to accept new tasks. False if the robot
    /// will not accept any new tasks.
    bool is_commissioned() const;

    /// Stop this robot from accepting any new tasks. It will continue to
    /// perform tasks that are already in its queue. To reassign those tasks,
    /// you will need to use the task request API to cancel the tasks and
    /// re-request them.
    void decommission();

    /// Allow this robot to resume accepting new tasks.
    void recommission();

    /// Get the schedule participant of this robot
    rmf_traffic::schedule::Participant* get_participant();

    /// Change the radius of the footprint and vicinity of this participant.
    void change_participant_profile(
      double footprint_radius,
      double vicinity_radius);

    /// Override the schedule to say that the robot will be holding at a certain
    /// position. This should not be used while tasks with automatic schedule
    /// updating are running, or else the traffic schedule will have jumbled up
    /// information, which can be disruptive to the overall traffic management.
    void declare_holding(
      std::string on_map,
      Eigen::Vector3d at_position,
      rmf_traffic::Duration for_duration = std::chrono::seconds(30));

    /// Get the current Plan ID that this robot has sent to the traffic schedule
    rmf_traffic::PlanId current_plan_id() const;

    /// Hold onto this class to tell the robot to behave as a &quot;stubborn
    /// negotiator&quot;, meaning it will always refuse to accommodate the schedule
    /// of any other agent. This could be used when teleoperating a robot, to
    /// tell other robots that the agent is unable to negotiate.
    ///
    /// When the object is destroyed, the stubbornness will automatically be
    /// released.
    class Stubbornness
    {
    public:
      /// Stop being stubborn
      void release();

      class Implementation;
    private:
      Stubbornness();
      rmf_utils::impl_ptr&lt;Implementation&gt; _pimpl;
    };

    /// Tell this robot to be a stubborn negotiator.
    Stubbornness be_stubborn();

    enum class Decision
    {
      Undefined = 0,
      Clear = 1,
      Crowded = 2
    };

    /// A callback with this signature will be given to the watchdog when the
    /// robot is ready to enter a lift. If the watchdog passes in a true, then
    /// the robot will proceed to enter the lift. If the watchdog passes in a
    /// false, then the fleet adapter will release its session with the lift and
    /// resume later.
    using Decide = std::function&lt;void(Decision)&gt;;

    using Watchdog = std::function&lt;void(const std::string&amp;, Decide)&gt;;

    /// Set a callback that can be used to check whether the robot is clear to
    /// enter the lift.
    void set_lift_entry_watchdog(
      Watchdog watchdog,
      rmf_traffic::Duration wait_duration = std::chrono::seconds(10));

  private:
    friend Implementation;
    Implementation* _pimpl;
  };

  /// Get a mutable reference to the unstable API extension
  Unstable&amp; unstable();
  /// Get a const reference to the unstable API extension
  const Unstable&amp; unstable() const;

private:
  RobotUpdateHandle();
  rmf_utils::unique_impl_ptr&lt;Implementation&gt; _pimpl;
};

using RobotUpdateHandlePtr = std::shared_ptr&lt;RobotUpdateHandle&gt;;
using ConstRobotUpdateHandlePtr = std::shared_ptr&lt;const RobotUpdateHandle&gt;;

} // namespace agv
} // namespace rmf_fleet_adapter



</code></pre>
<p><code>update_position</code>
This function updates the position of the robot by specifying -<code>waypoint</code>-The waypoint the robot is on.</p>
<ul>
<li>
<p><code>orientation</code> - Current orientation of the robot.'</p>
<p>or</p>
</li>
<li>
<p><code>position</code> -position of the robot and one or more lanes that the robot is occupying.</p>
</li>
<li>
<p><code>lanes</code> - number of lanes(minimum 1 required)</p>
<p>or</p>
</li>
<li>
<p><code>position</code> -position of the robot and one or more lanes that the robot is occupying.</p>
</li>
<li>
<p><code>target_waypoint</code> - number of lanes(minimum 1 required)
This should be used if the robot has diverged significantly from its
course but it is merging back onto a waypoint.</p>
<p>or</p>
</li>
<li>
<p><code>map_name</code> - The map robot is on</p>
</li>
<li>
<p><code>position</code> -position of the robot and one or more lanes that the robot is occupying.
This option should be used if the robot has diverged significantly from its course.
The parameters for this function are passed along to <code>rmf_traffic::agv::compute_plan_starts()</code>.</p>
<p>or</p>
</li>
<li>
<p><code>position</code> The plan set for the robot</p>
</li>
</ul>
<p><code>replan</code>
The function will tell the RMF schedule that the robot requires a new plan. The new plan will have the starting position of the robot as the last position the robot had updated using <code>update_position()</code>.</p>
<p><code>set_charger_waypoint</code>
Set the waypoint where the charger for this robot is located.If not specified, the nearest waypoint in the graph with the is_charger()
property will be assumed as the charger for this robot.</p>
<ul>
<li><code>charger_wp</code> The waypoint where the charger for this robot is located.</li>
</ul>
<p><code>update_battery_soc</code>
Update the current battery level of the robot by specifying its state of charge as a fraction of its total charge capacity.</p>
<p><code>override_status</code> This function overrides the robot status.</p>
<ul>
<li><code>status</code>The string provided must
be a valid enum as specified in the robot_state.json schema.
Pass std::nullopt to cancel the override and allow RMF to automatically
update the status. The default value is std::nullopt.</li>
</ul>
<p><code>maximum_delay</code>
Specify how high the delay of the current itinerary can become before it gets interrupted and replanned. A nullopt value will allow for an
arbitrarily long delay to build up without being interrupted.</p>
<p><code>ActionExecution</code></p>
<ul>
<li>
<p><code>underways</code>
Set task status to error and optionally log a message (error tier)</p>
</li>
<li>
<p><code>errors</code>
Set the task status to delayed and optionally log a message
(warning tier)</p>
</li>
<li>
<p><code>delayeds</code>
Set the task status to blocked and optionally log a message
(warning tier)</p>
</li>
<li>
<p><code>blockeds</code>
Trigger this when the action is successfully finished</p>
</li>
<li>
<p><code>finished</code>
Returns false if the Action has been killed or cancelled</p>
</li>
</ul>
<p><code>submit_direct_request</code></p>
<ul>
<li><code>task_request</code> A JSON description of the task request. It should match the task_request.json schema of rmf_api_msgs, in particular it must contain</li>
<li><code>request_id</code> The unique ID for this task request.</li>
<li><code>receive_response</code> Provide a callback to receive the response. The response will be a robot_task_response.json message from rmf_api_msgs (note: this message</li>
</ul>
<p><code>ActionExecutor</code>
Signature for a callback to request the robot to perform an action</p>
<ul>
<li>
<p><code>category</code>
A category of the action to be performed</p>
</li>
<li>
<p><code>description</code>
A description of the action to be performed</p>
</li>
<li>
<p><code>execution</code>
An ActionExecution object that will be provided to the user for
updating the state of the action.</p>
</li>
</ul>
<p><code>set_action_executor</code> Set the ActionExecutor for this robot</p>
<p><code>submit_direct_request</code> Send a request to the robot.</p>
<ul>
<li><code>task_request</code> The json task request</li>
<li><code>request_id</code> The request ID for the task request</li>
<li><code>receive_response</code> The response callback</li>
</ul>
<p><code>interrupt</code> Interrupt (pause) the current task, yielding control of the robot away
from the fleet adapter's task manager.</p>
<ul>
<li><code>labels</code>
Labels that will be assigned to this interruption. It is recommended to
include information about why the interruption is happening.</li>
</ul>
<p><code>cancel_task</code>
Cancel a task, if it has been assigned to this robot</p>
<ul>
<li>
<p><code>task_id</code>
The ID of the task to be canceled</p>
</li>
<li>
<p><code>labels</code>
Labels that will be assigned to this cancellation. It is recommended to
include information about why the cancellation is happening.</p>
</li>
<li>
<p><code>on_cancellation</code>
Callback that will be triggered after the cancellation is issued.
task_was_found will be true if the task was successfully found and
issued the cancellation, false otherwise.</p>
</li>
</ul>
<p><code>kill_task</code> Kill a task, if it has been assigned to this robot</p>
<ul>
<li>
<p><code>task_id</code>
The ID of the task to be canceled</p>
</li>
<li>
<p><code>labels</code>
Labels that will be assigned to this cancellation. It is recommended to
include information about why the cancellation is happening.</p>
</li>
<li>
<p><code>on_kill</code>
Callback that will be triggered after the cancellation is issued.
task_was_found will be true if the task was successfully found and
issued the kill, false otherwise.</p>
</li>
</ul>
<p><code>create_issue</code> Create a new issue for the robot.</p>
<ul>
<li>
<p><code>tier</code>
The severity of the issue</p>
</li>
<li>
<p><code>category</code>
A brief category to describe the issue</p>
</li>
<li>
<p><code>detail</code>
Full details of the issue that might be relevant to an operator or
logging system.</p>
</li>
</ul>
<p><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/RobotCommandHandle.hpp"><code>RobotCommandHandle</code></a>
This class works as a bridge and acts as a handler for all the commands that need to be sent to the robot.</p>
<pre><code class="language-cpp">namespace rmf_fleet_adapter {
namespace agv {

//==============================================================================
/// Implement this class to receive robot commands from RMF
class RobotCommandHandle
{
public:

  using Duration = rmf_traffic::Duration;

  using ArrivalEstimator =
    std::function&lt;void(std::size_t path_index, Duration remaining_time)&gt;;

  /// Trigger this callback function when the follow_new_path request has been
  /// completed. It should only be triggered that one time and then discarded.
  using RequestCompleted = std::function&lt;void()&gt;;


  virtual void follow_new_path(
    const std::vector&lt;rmf_traffic::agv::Plan::Waypoint&gt;&amp; waypoints,
    ArrivalEstimator next_arrival_estimator,
    RequestCompleted path_finished_callback) = 0;

  /// Have the robot come to an immediate stop.
  virtual void stop() = 0;


  virtual void dock(
    const std::string&amp; dock_name,
    RequestCompleted docking_finished_callback) = 0;

  // Virtual destructor
  virtual ~RobotCommandHandle() = default;
};

} // namespace agv
} // namespace rmf_fleet_adapter

</code></pre>
<p><code>ArrivalEstimator</code>
Use this callback function to update the fleet adapter on how long the
robot will take to reach its next destination.</p>
<ul>
<li>
<p><code>path_index</code>
The index of the path element that the robot is currently heading
towards.</p>
</li>
<li>
<p><code>remaining_time</code>
An estimate of how much longer the robot will take to arrive at
<code>path_index</code>.</p>
</li>
</ul>
<p><code>follow_new_path</code> Have the robot follow a new path. If it was already following a path, then
it should immediately switch over to this one.</p>
<ul>
<li>
<p><code>waypoints</code>
The sequence of waypoints to follow. When the robot arrives at a
waypoint in this sequence, it should wait at that waypoint until the
clock reaches the time() field of the waypoint. This is important
because the waypoint timing is used to avoid traffic conflicts with
other vehicles.</p>
</li>
<li>
<p><code>next_arrival_estimator</code>
Use this callback to give estimates for how long the robot will take to
reach the path element of the specified index. You should still be
calling RobotUpdateHandle::update_position() even as you call this
function.</p>
</li>
<li>
<p><code>path_finished_callback</code>
Trigger this callback when the robot is done following the new path.</p>
</li>
</ul>
<p>You do not need to trigger waypoint_arrival_callback when triggering
this one.</p>
<p><code>dock</code> Have the robot begin a pre-defined docking procedure. Implement this
function as a no-op if your robots do not perform docking procedures.</p>
<ul>
<li>
<p><code>dock_name</code>
The predefined name of the docking procedure to use.</p>
</li>
<li>
<p><code>docking_finished_callback</code>
Trigger this callback when the docking is finished.</p>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_fleets_tutorial_cpp.md">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="integration_fleets_tutorial_python.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="integration_free-fleet.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="integration_fleets_tutorial_python.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="integration_free-fleet.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
